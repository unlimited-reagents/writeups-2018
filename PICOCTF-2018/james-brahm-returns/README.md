## Problem - James Brahm Returns

### Introduction

From the problem statement and the hint (AES CBC Mode, SSL3), we can guess that this problem involves some sort of POODLE attack, which was what killed SSL3. [Helpful Reading](https://www.openssl.org/~bodo/ssl-poodle.pdf)

However, this problem is not as simple as the 450 point Magic Padding Oracle problem, which uses a more straightforward padding oracle attack. Instead, we must modify POODLE attack slightly to fit within the constraints of this problem.

### Attack Description

#### AES CBC Description

![alt-text](https://upload.wikimedia.org/wikipedia/commons/thumb/2/2a/CBC_decryption.svg/640px-CBC_decryption.svg.png "AES CBC Decryption")

The AES encrypted message generated by the server can be seen to have these components, which is very similar to other SSL3 encoded messages.

|     IV    |  Message  |    MAC    |          Padding          |
|:---------:|:---------:|:---------:|:-------------------------:|
|  16 bytes  |  n bytes  |  40 bytes | fills the rest of a block |

The server creates this ciphertext by encrypting some message. Encryption takes a few stages:

1. A SHA1 hash of this message is computed before encryption and appended to the message
2. To ensure that the plaintext can be divided into 16 byte blocks, a padding is added. In this case, the padding is just `chr(length_padding)` repeated for the length of the padding. If the plaintext is already divisible by 16, an entirely new block of padding is added
3. A random 16 byte initialization vector (IV) is  generated. Note that the server does not allow reuse of IVs
4. The full plaintext is split up into blocks of length 16
5. The first block is XORed with the IV, then encrypted with a key
6. All subsequent blocks are XORed with the ciphertext of the block before them, then encrypted with the key
7. The IV is prepended to the ciphertext

This produces a ciphertext matching that in the table above.

To decrypt the message, a process similar to the reverse of encryption is used:

1. The initialization vector is saved and removed from the message
2. The first block of ciphertext is decrypted, then XORed with the IV to get back plaintext. Let the decryption operation be denoted by D(c<sub>0</sub>). The final result of this step is given by D(c<sub>0</sub>) XOR IV
3. All subsequent blocks are decrypted, then XORed with the ciphertext of the preceding block. Let c<sub>i</sub> be the ciphertext of block `i`, so this step is given by D(c<sub>i</sub>) XOR c<sub>i-1</sub>

After decryption, we are left with the decrypted message, a MAC, and the padding.

The server then checks the last byte of the padding, which represents the length of the padding. It specifically checks to make sure that this is a valid length (0<pad<17), then removes the padding from the message.

Then, the server checks to make sure the SHA1 hash of the message matches the MAC in the plaintext.

If all these conditions are satisfied, the server will return `Successful decryption.` Otherwise, the server will return `Ooops! Did not decrypt successfully. Please send again.`

It should be noted that there are two stages in the process that can cause the server to unsuccessfully decrypt the message, assuming unique IV and proper message length:
- Incorrect padding last byte (length)
- Incorrect MAC

We want to find a way to use the server's response to our advantage.

#### POODLE Description

##### Server Overview

The server has two options, encrypt and decrypt. We will need to use both heavily for this exploit.

More specifically, encrypt lets the user input both a situation report and a PS. These two strings are inserted into a message template with the flag in it, which is then encrypted. Important to remember for later is the ability to insert text before (situation report) and after (PS) the flag in the message.

The first thing we need to do is figure out how much extra text we need to have the server encrypt in order to generate a full block of padding. Basically, we need to make sure the message+MAC is a multiple of 16 long. After some trial and error, we get that this number is `14`, meaning that we can input anything of length `14 (mod 16)` and get a full block of padding.

This is important as we now have a full block of padding that contains no part of the MAC. In addition, the MAC doesn't check the padding, meaning that we now have a block to play around with without worrying about the MAC!

##### Extracting a Single Byte

Let's say we take an arbitrary block (block `k`) from the ciphertext and replace the block of padding with it. There is only one possible way for this message to decrypt correctly: if the last byte of plaintext happens to be `chr(16)=\x10`. Only then will the padding removal to succeed in removing an entire block, allowing the MAC check to pass.

Let's further break down what it means for the last byte of the plaintext to be `chr(16)`. Recall the steps of decryption. The last byte of the plaintext is dependent on our own custom padding block (block `k`), the ciphertext of the preceding block (block `-2` in Python syntax), and the block cipher decryption.

If the last byte if `chr(16)`, that means that the decrypted intermediate of block `k` XOR ciphertext of block `-2` ends with `chr(16)`. In other words, D(c<sub>k</sub>) XOR c<sub>-2</sub> ends with `chr(16)`. More specifically, the last byte of D(c<sub>k</sub>) XOR c<sub>-2</sub> is `chr(16)`, which can be written: D(c<sub>k</sub>)[15] XOR c<sub>-2</sub>[15] = `\x10`.

This means that we can get one byte of our manipulated ciphertext! Specifically, we can get the last byte of block `k`, the block we chose to replace the padding with. It can be seen how we get this byte through the following steps (let P<sub>i</sub> be the plaintext of block `i`):

`\x10` = D(c<sub>k</sub>)[15] XOR c<sub>-2</sub>[15]  
D(c<sub>k</sub>)[15] = `\x10` XOR c<sub>-2</sub>[15]

We know from normal AES decryption that:  
P<sub>k</sub>[15] = D(c<sub>k</sub>)[15] XOR c<sub>k-1</sub>[15]

Substituting in for D(c<sub>k</sub>)[15], we get:  
P<sub>k</sub>[15] = `\x10` XOR c<sub>-2</sub>[15] XOR c<sub>k-1</sub>[15]

This is important, as we see we have gotten a formula for a byte of the plaintext that only requires knowledge of the ciphertext!

However, this only will work if the message actually manages to decrypt. In most cases, an error will be thrown.

Reuse check for the IV as well as MAC validation check prevents us from modifying the ciphertext manually. However, there is another way.

As the server randomizes the IV every time a new encryption is requested, we can simply keep requesting the same text to be encrypted, replace the padding with block `k`, and test decryption repeatedly until it finally works! This should only take at most a few hundred attempts per byte, although it could take much shorter or even much longer.

##### Extracting Many Bytes

From the previous section, we have learned how to extract the last byte of the ciphertext of an arbitrary block `k`. To extract multiple bytes, we simply repeat the process, but shifted over.

This is where it becomes important that we can insert text before and after the flag. In my implementation, I bashed from back to front of the flag. This can be done by first bashing the last byte. To move forward one byte, we simply need to remove one byte from the PS text and add one byte to the situation report. This has the effect of shifting the flag over one byte while maintaining the length of the message, which allows you to bash a sequence of bytes in the message!

### Implementation

#### Problem Details

Specifically for this problem, the flag is stored in the `agent identifying code`. Looking at the message provided tells us that with a blank situation report, the flag will start in block 6 (where block 0 is the IV and block 1 is the first message block). To get the full flag, let's bash all of blocks 6 and 7 and terminate early if necessary.

In my implementation, I ended up bashing back to front, although it could just as easily be done front to back.

To bash blocks 6 and 7 back to front, we start with the last byte of block 7 and gradually shift the flag using the technique described above. More concretely, we set the initial situation report to be empty and the PS to be `"a"*(14+32)` to get a full block of padding as well as enough length to bash two full blocks.

For every iteration of bashing, we remove one `a` from the PS and add it to the initial situation report. Eventually, this should give us the flag!

#### Code

I used the python library `pwn` in this problem to connect to the server and encrypt and decrypt.

We set up the connection with: `vuln = process(['nc', '2018shell2.picoctf.com', '15608'])` and wait for the server to connect:

```python
while "006" not in vuln.readline():
    pass
for i in range(3):
    vuln.readline()
```

A few variables are set:

```python
bashLen = 32
block = 7
initBegin = ''
initEnd = 'a'*(14+bashLen)
answer = ''
```

`initBegin` is the  situation report, while `initEnd` is the PS.

We begin a loop to bash through each character: `for i in range(0, bashLen):` and an inner loop to bash the byte: `while True:`

The first part of the code fetches the encrypted text from the server, and replaces the padding with the specified block (block `7`):

```python
vuln.sendline("e")
vuln.sendline(initBegin)
vuln.sendline(initEnd)
encStr = vuln.recvline().split(" ")[-1].rstrip()
sendStr = encStr[:-32]+encStr[block*32:block*32+32]
```

We then send the manipulated string back to the server and read the return message:

```python
for j in range(3):
    vuln.readline()
vuln.sendline("s")
vuln.sendline(sendStr)
status = vuln.readline().strip()
for j in range(3):
    vuln.readline()
```

If we detect that it was decrypted successully, then we can calculate the char through 2 XORs (process previously described): `lastChar = chr(int(encStr[-34:-32], 16)^16^int(encStr[block*32-2:block*32], 16))`

We append this to the answer and move to the next char.

Sometimes, the connection to the server would drop, so we wrapped the bashing code in a `try:` `except EOFError:` block. If the connection dropped, we would reconnect.

The full code is available at [jamespwn.py](https://github.com/unlimited-reagents/writeups-2018/blob/master/PICOCTF-2018/james-brahm-returns/jamespwn.py).

After running, we can terminate early after noticing a curly brace, signaling the end of our flag!